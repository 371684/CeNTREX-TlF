import numpy as np
from sympy import Symbol
import scipy.constants as cst
# from centrex_TlF import State
from dataclasses import dataclass
from scipy.sparse import kron, eye
from centrex_TlF.utils import (
    calculate_power_from_rabi_gaussian_beam,
    calculate_rabi_from_power_gaussian_beam
)

__all__ = [
    "generate_total_hamiltonian"
]

def generate_sharp_superoperator(M, identity = None):
    """
    Given an operator M in Hilbert space, generates sharp superoperator M_L in 
    Liouville space (see "Optically pumped atoms" by Happer, Jau and Walker)
    sharp = post-multiplies density matrix: |rho@A) = A_sharp @ |rho) 

    inputs:
    M = matrix representation of operator in Hilbert space

    outputs:
    M_L = representation of M in in Liouville space
    """

    if identity == None:
         identity = eye(M.shape[0], format = 'coo')

    M_L = kron(M.T,identity, format = 'csr')

    return M_L

def generate_flat_superoperator(M, identity = None):
    """
    Given an operator M in Hilbert space, generates flat superoperator M_L in 
    Liouville space (see "Optically pumped atoms" by Happer, Jau and Walker)
    flat = pre-multiplies density matrix: |A@rho) = A_flat @ |rho)

    inputs:
    M = matrix representation of operator in Hilbert space

    outputs:
    M_L = representation of M in in Liouville space
    """
    if identity == None:
         identity = eye(M.shape[0], format = 'coo')

    M_L = kron(identity, M, format = 'csr')

    return M_L

def generate_superoperator(A,B):
    """
    Function that generates superoperator representing 
    |A@rho@B) = np.kron(B.T @ A) @ |rho)

    inputs:
    A,B = matrix representations of operators in Hilbert space

    outpus:
    M_L = representation of A@rho@B in Liouville space
    """

    M_L = kron(B.T, A, format = 'csr')

    return M_L

def generate_total_hamiltonian(H_int, QN, couplings):
    """Generate the total rotating frame Hamiltonian

    Args:
        H_int (np.ndarray; complex): internal Hamiltonian
        QN (list, array): array with states
        couplings (dict): dictionary with information about couplings between 
                        states; generated by generate_coupling_field

    Returns:
        np.ndarray; complex: rotating frame Hamiltonian
    """ 
    H_rot = H_int.copy()
    for coupling in couplings:
        gnd_idx = QN.index(coupling['ground main'])
        H_rot -= np.eye(len(H_rot))*H_rot[gnd_idx,gnd_idx]
        H_rot += coupling['D']
    return H_rot

def check_transitions(transitions):
    ground_states = np.concatenate([transition['ground states approx'] 
                        for transition in transitions])
    excited_states = np.concatenate([transition['excited states approx'] 
                        for transition in transitions])
    ground_states = np.concatenate([list(zip(*gs.data))[1] for gs in ground_states])
    excited_states = np.concatenate([list(zip(*es.data))[1] for es in excited_states])
    for gs in ground_states:
        assert gs not in excited_states, f"{gs} is both ground state and excited state"

# @dataclass
# class Transition:
#     ground: State
#     excited: State
#     ground_states: np.ndarray
#     excited_states: np.ndarray
#     main_polarization: np.ndarray
#     polarizations: list
#     polarization_symbols: list
#     Ω: Symbol
#     δ: Symbol
#     description: str
#     type: str

# @dataclass
# class Coupling:
#     ground: State
#     excited: State
#     main_coupling: complex
#     ground_states: np.ndarray
#     excited_states: np.ndarray
#     D: np.ndarray
#     fields: list
#     type: str
#     dipole: float

#     def rabi_from_power(self, P, σx, σy):
#        return calculate_rabi_from_power_gaussian_beam(
#             P, self.main_coupling, σx, σy, self.dipole
#         )
    
#     def power_from_rabi(self, Ω, σx, σy):
#         return calculate_power_from_rabi_gaussian_beam(
#             Ω, self.main_coupling, σx, σy, self.dipole
#         )